---
const server = import.meta.env.PUBLIC_SERVER_IP || "http://localhost:6767";
---

<div id="container">
	<canvas id="canvas" height="100%" width="100%"></canvas>
</div>

<script type="module" is:inline define:vars={{ server }}>
	var canvas = document.querySelector("#canvas");
	const ctx = canvas.getContext("2d");

	var scale = 0.1;
	var down = false;
	var lastMouseX = 0;
	var lastMouseY = 0;
	var dx = 0; // User dragged offset
	var dy = 0;
	var tiles;
	var items = {};
	var bitmaps = {};
	var detaillevels = [];
	var requested = {};
	var parts = 81;
	var n = 9; // n x n parts
	var readybitmaps = 0;
	var mapw = 0; //Width of full map
	var maph = 0; //Height of full map

	function calculateCurrentDetailLevel(scale) {
		if (scale < 0.5) return 25;
		if (scale < 1) return 50;
		return 100;
	}

	function calculteCurrentlyVisibleRects(
		canvas_width,
		canvas_height,
		dx,
		dy,
	) {
		let visibleWorldW = canvas_width / scale;
		let visibleWorldH = canvas_height / scale;

		let left = mapw / 2 - visibleWorldW / 2 - dx;
		let top = maph / 2 - visibleWorldH / 2 - dy;

		let tilewidth = mapw / n;
		let tileheight = maph / n;

		let firstleft = Math.floor(left / tilewidth) - 1;
		let firsttop = Math.floor(top / tileheight) - 1;

		let max_tiles_w = Math.ceil(visibleWorldW / tilewidth) + 2;
		let max_tiles_h = Math.ceil(visibleWorldH / tileheight) + 2;

		let startCol = Math.max(0, firstleft);
		let startRow = Math.max(0, firsttop);
		let endCol = Math.min(n-1, startCol + max_tiles_w);
		let endRow = Math.min(n-1, startRow + max_tiles_h);


		return [startCol, startRow, endCol, endRow];
	}

	async function requestMetaData(){
		const response = await fetch(
			`${server}/meta`
		);
		const data = await response.json();
		if (data) {
			console.log(data)
			n = data.n;
			parts = data.numparts;
			detaillevels = data.detaillevels.sort().reverse();
		}
	}

	async function requestTile(index, quality) {
		const response = await fetch(
			`${server}/images/${quality}/output_` + index + ".jpg",
		);
		const data = await response.blob();
		const bitmap = await createImageBitmap(data);
		items[quality][index] = bitmap;
	}

	function getTileNFromCache(index, quality = 100) {
		if (quality in items) {
			if (index in items[quality]) { // Cache hit. return.
				return items[quality][index];
			}
			let lowerQualityFallback;
			for(const i of detaillevels){
				if(i in items && index in items[i]){
						lowerQualityFallback = items[i][index];
						if(i>quality)
							return lowerQualityFallback; // we already have the higher quality. return that
						break; // we found a lower quality of the tile. return that for drawing.
				}
			}
			if(index in requested && requested[index].includes(quality))
			{
				// The tile is already in retrieval request.
			}else{
				if(requested[index] == undefined) // Nobody ever requested this tile.
					requested[index] = [];
				requested[index].push(quality); // Tell other "threads" that we are already requesting 
				requestTile(index, quality)     // this tile.
			}
			if(lowerQualityFallback != undefined){ 
				return lowerQualityFallback; 
			}
			return null;// There was no lower quality and we might still be waiting for request to finish
		}
		items[quality] = {};
		return getTileNFromCache(index, quality);
	}

	async function fetchData() {
		try {
			const response = await fetch(`${server}/maps`);
			const data = await response.json();
			tiles = data;
			console.log(data);
			tiles.forEach((element) => {
				mapw += element.width;
				maph += element.height;
			});
			mapw /= tiles.length;
			mapw *= n;
			maph /= tiles.length;
			maph *= n;
		} catch (error) {}
	}
	
	requestMetaData().then(()=>{
		fetchData().then(() => {
			scale = Math.max(0.12,canvas.height / maph);

			tiles.forEach((element) => {
				getTileNFromCache(
					element.id,
					calculateCurrentDetailLevel(scale),
				);
				readybitmaps++;
			});
		});
	});

	function resize() {
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}

	resize();

	window.addEventListener("resize", resize);


	let timeToSleep = 1000;

	function draw() {
		if(timeToSleep<=0) {requestAnimationFrame(draw);return;} // Do not redraw if inactive.
		timeToSleep=Math.max(0,timeToSleep-1); // Do not go below 0

		ctx.setTransform(1, 0, 0, 1, 0, 0);

		ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
		const centerX = canvas.width / 2;
		const centerY = canvas.height / 2;

		ctx.translate(centerX, centerY);
		ctx.fillStyle = "green";
		ctx.scale(scale, scale);

		ctx.translate(-centerX, -centerY);
		let x = 0;
		let y = 0;
		let ix = 0;
		let iy = 0;
		let i = 0;
		let j = 0;

		x = -mapw / 2 + canvas.width / 2;
		y = -maph / 2 + canvas.height / 2;
		ix = mapw / n;
		iy = maph / n;

		let bounds = calculteCurrentlyVisibleRects(
			canvas.width,
			canvas.height,
			dx,
			dy,
		);

		let detail = calculateCurrentDetailLevel(scale);

		for (let i = bounds[0]; i <= bounds[2]; i++) {
			for (let j = bounds[1]; j <= bounds[3]; j++) {
				let eli = i + j * n;
				let el = getTileNFromCache(eli,detail);
				 if (el) {
					 ctx.drawImage(
						 el,
						 dx + i * ix + x,
						 dy + j * iy + y,
						 ix, // Use calculated tile width
						 iy, // Use calculated tile height
					 );
				 }
			}
		}
		requestAnimationFrame(draw);
	}

	document.addEventListener("wheel", (WheelEvent) => {
		if (WheelEvent.deltaY > 0) {
			scale *= 1.05;
		} else {
			scale *= 0.9;
		}
		timeToSleep+=5;
	});


	document.addEventListener("mousedown", (event) => {
		down = true;
	});
	document.addEventListener("mouseup", (event) => {
		down = false;
	});
	document.addEventListener("mousemove", (event) => {
		if (down) {
			dx += event.movementX / scale;
			dy += event.movementY / scale;
			timeToSleep+=5;
		}
	});

	draw();
</script>

<style>
	body {
		overflow: hidden;
	}
	#container {
		width: 100%;
		height: 100%;
		padding: 0, 0, 0, 0;
	}
</style>
